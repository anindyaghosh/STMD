% A function to generate imagery. Intended to be used when rendering an
% acute zone. To facilitate that, this can be run with a target position
% history.
% Two subsampled images are generated at once - one with coarse field of
% view and blur settings and the other with fine. There's not actually any
% need for coarse to be coarser than fine.
%
% OUTPUTS
% im_ss_coarse,im_ss_fine,...
% h_pixelpos_coarse,v_pixelpos_coarse,...
% h_pixelpos_fine,v_pixelpos_fine
%
% INPUTS
% impath - Full path to panoramic image
% t_width,t_height,t_value - Target dimensions (degrees) and luminance (0
% to 1)
% hfov_coarse,vfov_coarse - Coarse field of view in degrees
% fwhm_coarse - Coarse full width at half maximum (degrees) for blur kernel
% hfov_fine,vfov_fine - Fine field of view in degrees
% fwhm_fine - Fine full width at half maximum (degrees) for blur kernel
% frames - Number of frames to render
% delay - Number of frames before target appears
% Ts - Time step in seconds
% drawmode - Only 'pixels' is valid currently. Basically the target can be
% drawn in several ways depending on whether one wants a constant pixelwise
% size or angular size. 'pixels' creates a target of constant pixelwise
% size.
% obs_th_input,t_al_pos_input,t_th_pos_input - The input observer and
% target angles. Note that the observer is always looking at alpha=0;
% pixel_per_degree - How many pixels per degree in the flattened image.
% degree_per_PR_coarse,degree_per_PR_fine - How many degrees per
% photoreceptor (relevant to subsampling). Higher values mean coarser
% subsampling.

function [  im_ss_coarse,im_ss_fine,...
            h_pixelpos_coarse,v_pixelpos_coarse,...
            h_pixelpos_fine,v_pixelpos_fine]=RenderRepeatPath18_06_12(...
            impath,...
            t_width,t_height,t_value,...
            hfov_coarse,vfov_coarse,fwhm_coarse,...
            hfov_fine,vfov_fine,fwhm_fine,...
            frames,delay,Ts,...
            drawmode,...
            obs_th_input,t_al_pos_input,t_th_pos_input,...
            pixel_per_degree,...
            degree_per_PR_coarse,degree_per_PR_fine)

         [  V_coarse,...
            V_fine,...
            H_coarse,...
            H_fine,...
            vpix_coarse,...
            hpix_coarse,...
            vpix_fine,...
            hpix_fine,...
            src,...
            panpix,...
            kernel_dim_fine,...
            kernel_dim_coarse,...
            fine_h,...
            fine_v,...
            coarse_h,...
            coarse_v,...
            kernel_fine,...
            kernel_coarse,...
            alp_coarse,...
            alp_fine,...
            theta_coarse,...
            theta_fine,...
            blurbound_coarse,...
            blurbound_fine,...
            hdist_coarse,...
            hdist_fine,...
            t_pixelleft_coarse,...
            t_pixelright_coarse,...
            t_pixeldown_coarse,...
            t_pixelup_coarse,...
            t_pixelleft_fine,...
            t_pixelright_fine,...
            t_pixeldown_fine,...
            t_pixelup_fine]=JJ_Draw_Setup18_06_07(...
    hfov_coarse,...
    vfov_coarse,...
    hfov_fine,...
    vfov_fine,...
    impath,...
    t_width,...
    t_height,...
    pixel_per_degree,...
    degree_per_PR_coarse,...
    degree_per_PR_fine,...
    fwhm_coarse,...
    fwhm_fine);

% Pixelwise subsampling
% pixel_per_PR= pixel_per_degree*degree_per_PR;
% alp_ss=alp_coarse((1+blurbound_coarse):pixel_per_PR:end-blurbound_coarse,(1+blurbound_coarse):pixel_per_PR:end-blurbound_coarse);
% theta_ss=repmat(theta_coarse(1,(1+blurbound_coarse):pixel_per_PR:end-blurbound_coarse),vfov,1);

% TODO: Degreewise subsampling

% Allocate memory for target and bg position histories
% t_th_pos=0;
% t_th_destination = 0;
% t_th_pos_hist=zeros(frames,1);
% t_al_pos_hist=t_th_pos_hist;
% obs_th_pos_hist=t_th_pos_hist;
% t_th_rel_hist=t_th_pos_hist;
% t_al_rel_hist=t_th_pos_hist;
% h_pixelpos_hist=t_th_pos_hist;
% v_pixelpos_hist=t_th_pos_hist;
% dist_hist=t_th_pos_hist;
% max_loc_hist=zeros(frames,2);

t_th_rel=t_th_pos_input-obs_th_input;

h_pixelpos_coarse=round(hdist_coarse*tand(t_th_rel)+hpix_coarse/2);
v_pixelpos_coarse=round(hdist_coarse*tand(t_al_pos_input)./cosd(t_th_rel)+vpix_coarse/2);
h_pixelpos_fine=round(hdist_fine*tand(t_th_rel)+hpix_fine/2);
v_pixelpos_fine=round(hdist_fine*tand(t_al_pos_input)./cosd(t_th_rel)+vpix_fine/2);

ind_logic_coarse=false(vpix_coarse,hpix_coarse);
ind_logic_fine=false(vpix_fine,hpix_fine);

im_ss_coarse=zeros([size(coarse_h) frames]);
im_ss_fine=zeros([size(fine_h) frames]);

for f=1:frames
    
    %generate background
    offset=floor(obs_th_input(f)/360*panpix);
    ind=sub2ind(size(src),V_coarse(:),round(offset+H_coarse(:)));
    ind(isnan(ind))=1;
    img_coarse=reshape(src(ind),vpix_coarse,hpix_coarse);
    
    ind_fine=sub2ind(size(src),V_fine(:),round(offset+H_fine(:)));
    ind_fine(isnan(ind_fine))=1;
    img_fine=reshape(src(ind_fine),vpix_fine,hpix_fine);
    %add target if it's in a place where it should be drawn
    if(f > delay)
        if(t_th_rel(f) > -hfov_coarse/2 && t_th_rel(f) < hfov_coarse/2 && t_al_pos_input(f) < vfov_coarse/2 && t_al_pos_input(f) > -vfov_coarse/2)
            if(strcmp(drawmode,'pixels')) %In this mode, the target has a constant pixel size, which means the angles change as it goes. Movement is by angles.
                x_left= max(h_pixelpos_coarse(f)-t_pixelleft_coarse,1);
                x_right= min(h_pixelpos_coarse(f)+t_pixelright_coarse,hpix_coarse);
                y_up= max(v_pixelpos_coarse(f)-t_pixelup_coarse,1);
                y_down= min(v_pixelpos_coarse(f)+t_pixeldown_coarse,vpix_coarse);
                ind_logic_coarse=false(size(ind_logic_coarse));
                ind_logic_coarse(y_up:y_down,x_left:x_right)=true;
            end
            img_coarse(ind_logic_coarse)=t_value;
        end
        if(t_th_rel(f) > -hfov_fine/2 && t_th_rel(f) < hfov_fine/2 && t_al_pos_input(f) < vfov_fine/2 && t_al_pos_input(f) > -vfov_fine/2)
            if(strcmp(drawmode,'pixels')) %In this mode, the target has a constant pixel size, which means the angles change as it goes. Movement is by angles.
                x_left= max(h_pixelpos_fine(f)-t_pixelleft_fine,1);
                x_right= min(h_pixelpos_fine(f)+t_pixelright_fine,hpix_fine);
                y_up= max(v_pixelpos_fine(f)-t_pixelup_fine,1);
                y_down= min(v_pixelpos_fine(f)+t_pixeldown_fine,vpix_fine);
                ind_logic_fine=false(size(ind_logic_fine));
                ind_logic_fine(y_up:y_down,x_left:x_right)=true;
            end
            img_fine(ind_logic_fine)=t_value;
        end
    end

    frame_coarse=zeros(size(coarse_h));
    for t=1:numel(coarse_h)
        ref_h=coarse_h(t);
        ref_v=coarse_v(t);
        frame_coarse(t)=sum(sum(img_coarse(ref_v-floor(kernel_dim_coarse/2):ref_v+floor(kernel_dim_coarse/2),...
            ref_h-floor(kernel_dim_coarse/2):ref_h+floor(kernel_dim_coarse/2)).*kernel_coarse));
    end
    
    im_ss_coarse(:,:,f)=frame_coarse;
    
    frame_fine=zeros(size(fine_h));
    for t=1:numel(fine_h)
        ref_h=fine_h(t);
        ref_v=fine_v(t);
        frame_fine(t)=sum(sum(img_fine(ref_v-floor(kernel_dim_fine/2):ref_v+floor(kernel_dim_fine/2),...
            ref_h-floor(kernel_dim_fine/2):ref_h+floor(kernel_dim_fine/2)).*kernel_fine));
    end
    
    im_ss_fine(:,:,f)=frame_fine;
%     if(f>delay)
%         imshow(img_fine,'InitialMagnification',500)
%         drawnow
%     end

end
